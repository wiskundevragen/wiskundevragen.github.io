---
description: "Een gratis online tool om afgeleides te berekenen! Toets eenvoudig je functie in en wij berekenen
de afgeleide ervan."
title: Afgeleide calculator &mdash; Afgeleide berekenen online!
see_also: ["afg_lijst", "prim_lijst", "plotter"]
redirect_from:
  - /afgeleide-calculator/
  - /afgeleide-calculator.html
---
Hier kun je online afgeleides berekenen! Nu ook met de mogelijkheid om partiële afgeleides te berekenen (zie extra
opties). Toets hieronder je functie in, en onze afgeleide calculator zal bepalen wat de afgeleide van deze functie is!
<br>
<br>
<b>Let op: Gebruik punten in plaats van komma's als decimaalscheidingsteken. Dus <mathEl data="2.5">2.5</mathEl> in
	plaats van <mathEl data="2{,}5">2,5</mathEl> voor het getal "twee en een half"</b>
<br>
<br>
<div style='margin-bottom: 20px;'>
	<label for='src-functie' class='inputLabel hidden'>Functie, zoals (sin(x))^2 * x</label>
	<input type="text" placeholder="Functie, zoals (sin(x))^2 * x" class="ticketForm hasLabel" id='src-functie'
		autocapitalize="none">
</div>
<div id=' results'>
	<div id='rescols'>
		<div>
			<h3><b>Jouw functie</b></h3>
			<div id='parsed-function' style='min-height: 24px;'></div>
		</div>
		<div style='margin-top: 12px;'>
			<h3><b>De afgeleide</b></h3>
			<div id="derived-function" style='min-height: 24px;'></div>
		</div>
	</div>
	<div id='evaluerenRes'>
		<h3 style='margin-top: 2rem;'><b>Geëvalueerd in <span id='evalPlek'>x=...</span></b></h3>
		<div id="echteEvalRes" style='min-height: 24px;'></div>
	</div>
</div>
<h2 style='margin-bottom: 0px;'>Extra Opties</h2>
<div>
	<label for='afleiden-naar' class='inputLabel hidden'>Afleiden naar welke variabele? (standaard is x)</label>
	<input type="text" placeholder="Afleiden naar welke variabele? (standaard is x)" class="ticketForm hasLabel"
		id='afleiden-naar' autocapitalize="none">
</div>
<div>
	<label for='evalueren' id='evaluerenLabel' class='inputLabel hidden'>Evalueren in x=...</label>
	<input type="text" placeholder="Evalueren in x=..." class="ticketForm hasLabel" id='evalueren'
		autocapitalize="none">
</div>
<p id='evalwarn'><b>Evalueren in multivariabele functies is momenteel nog niet mogelijk.</b></p>
<br>
<br>
<br>
Deze afgeleide rekenmachine wordt mogelijk gemaakt door <a href='https://mathjs.org/'>Math.js</a> en <a
	href="https://www.mathjax.org/">MathJax</a>.
<script src='../JS/math.js'></script>
<script>
	const texOptions = {
		implicit: "hide"
	};
	const synonyms = ['arctan', 'atan', 'arcsin', 'asin', 'arccos', 'acos', 'ln(', 'log('];
	const commonFns = synonyms.concat('exp', 'sin', 'cos', 'tan')

	function clearOutputs() {
		id("parsed-function").innerHTML = ''
		id("derived-function").innerHTML = ''
		id("echteEvalRes").innerHTML = '';
		id("evaluerenRes").classList.remove("shown");
	}

	window.addEventListener('DOMContentLoaded', (event) => {
		function inputEvent(event) {
			let els = document.querySelectorAll(".ticketForm");
			for (let i = 0; i < els.length; i++) {
				const el = els[i];
				let label = document.querySelector("label[for=\"" + el.id + "\"]");
				if (el.value) {
					if (label) {
						label.classList.remove("hidden");
					}
				} else {
					if (label) {
						label.classList.add("hidden");
					}
				}
			}
			let fn = id("src-functie").value;
			if (fn.split("(").length != fn.split(")").length || fn[fn.length - 1] == '^' || fn[fn.length - 1] == '*') {
				clearOutputs();
				return;
			}
			if (fn.split("=").length > 2) {
				id("src-functie").classList.add("errorInput");
				return;
			}
			fn = fn.split("=")[fn.split("=").length - 1];
			id("src-functie").classList.remove("errorInput");
			let emptyfunction = fn;
			fn = parseSynonyms(fn);
			for (let i = 0; i < commonFns.length; i++) {
				emptyfunction = replaceAll(emptyfunction, commonFns[i], "");
			}
			emptyfunction = replaceAll(emptyfunction, "(", "");
			emptyfunction = replaceAll(emptyfunction, ")", "");

			let ev = parseEv(replaceAll(id("evalueren").value, ',', '.'));
			let gaanEval = false;
			if (ev) {
				if (!isNaN(replaceAll(ev, ['Math.exp(1)', 'Math.PI', '*', '/', '+', '-'], ''))) {
					ev = eval(ev);
					gaanEval = true;
					id("evalueren").classList.remove("errorInput")
					id("evalwarn").classList.remove("shown");
					id("evalueren").classList.remove("errorInput");
				} else {
					id("evalueren").classList.add("errorInput")
				}
			} else {
				id("evalueren").classList.remove("errorInput")
				id("evalwarn").classList.remove("shown");
				id("evalueren").classList.remove("errorInput");
			}


			try {
				let afvar = id("afleiden-naar").value;
				if (afvar.replace(/[0-9]/g, '') != afvar || afvar.length > 1) {
					afvar = 'x';
					id("afleiden-naar").classList.add("errorInput")
				} else {
					id("afleiden-naar").classList.remove("errorInput")
				}
				let letters = uniques(emptyfunction.replace(/[^a-z]/ig, ''));
				if (letters.length > 1) {
					if (gaanEval) {
						gaanEval = false;
						id("evalwarn").classList.add("shown");
						id("evalueren").classList.add("errorInput");
					}
					if (!afvar) afvar = 'x';
				} else if (letters.length == 1) {
					if (!afvar) afvar = letters;
				} else {
					if (!afvar) afvar = 'x';
				}
				if (!afvar) afvar = 'x';
				id("evalueren").placeholder = 'Evalueren in ' + afvar + '=...';
				id("evaluerenLabel").innerHTML = 'Evalueren in ' + afvar + '=...';
				if (!fn || !fn.length) {
					throw 'fn not defined';
				}
				parsedFn = math.parse(fn);
				simplifiedFn = math.simplify(math.parse(fn));
				if (parsedFn.toTex() != simplifiedFn.toTex()) {
					id("parsed-function").innerHTML = "\\(\\begin{align*}f(" + afvar + ")&=" + parsedFn.toTex({ implicit: 'hide' }) + "\\\\&=" + simplifiedFn.toTex({ implicit: 'hide' }) + "\\end{align*}\\)";
				} else {
					id("parsed-function").innerHTML = "\\(f(" + afvar + ")=" + parsedFn.toTex() + "\\)";
				}

				deriv = calcDeriv(simplifiedFn, false, afvar);
				simplifiedDeriv = calcDeriv(simplifiedFn, true, afvar);
				if (deriv.toTex({ implicit: "hide" }) != simplifiedDeriv.toTex({ implicit: "hide" })) {
					id("derived-function").innerHTML = "\\(\\begin{align*}f'(" + afvar + ")&=" + deriv.toTex(texOptions) + "\\\\ &=" + simplifiedDeriv.toTex(texOptions) + "\\end{align*}\\)";
				} else {
					id("derived-function").innerHTML = "\\(f'(" + afvar + ")=" + deriv.toTex(texOptions) + "\\)";
				}
				if (gaanEval) {
					id("evalwarn").classList.remove("shown");
					id("evalueren").classList.remove("errorInput");
					id("evaluerenRes").classList.add("shown");
					id("evalPlek").innerHTML = '\\(' + afvar + '=' + ev + '\\)';

					let derivValue = evaluate(simplifiedDeriv, afvar, ev);
					let fnValue = evaluate(simplifiedFn, afvar, ev);

					id("echteEvalRes").innerHTML = '\\(f(' + ev + ')=' + fnValue + '\\)<br><br>\\(f\'(' + ev + ')=' + derivValue + '\\)';
				} else {
					id("evaluerenRes").classList.remove("shown");
				}
			} catch (err) {
				clearOutputs();
			}
			MathJax.typeset();
		};
		id("src-functie").addEventListener("input", inputEvent);
		id("afleiden-naar").addEventListener("input", inputEvent);
		id("evalueren").addEventListener("input", inputEvent);
	});

	function strip(number) {
		return parseFloat(number).toPrecision(12);
	}

	function evaluate(fn, afvar, ev) {
		let options = {};
		options[afvar] = ev;
		return math.simplify(strip(Math.round(fn.evaluate(options) * 1e6) / 1e6)).toTex();
	}

	function calcDeriv(fn, simplify, afvar) {
		if (simplify) {
			return math.simplify(
				math.derivative(simplifiedFn, afvar, { simplify: false })
			);
		} else {
			return math.simplify(
				math.derivative(simplifiedFn, afvar, { simplify: false }),
				["1*n1 -> n1", "-1*n1->-n1", "2-1->1", "3-1->2", "4-1->3", "5-1->4", "6-1->5", "7-1->5", "8-1->5", "9-1->5", "10-1->5", "n1^1->n1"]
			);
		}
	}

	function parseEv(ev) {
		return addMultiplications(addMultiplications(ev, 'pi', 'Math.PI'), 'e', 'Math.exp(1)');
	}

	function addMultiplications(expr, delim, rep) {
		let res = '';
		let p = expr.split(delim);
		for (let i = 0; i < p.length; i++) {
			if (!i) {
				res += p[i];
				continue;
			}
			if (res[res.length - 1] != '*' && res.length) res += '*'
			res += rep || delim;
			if (p[i][0] != '*') res += '*';
			res += p[i];
		}
		if (res[res.length - 1] == '*') res = res.substr(0, res.length - 1);
		return res;
	}

	function uniques(str) {
		let ar = str.split("");
		let res = [];
		for (let i = 0; i < ar.length; i++) {
			const a = ar[i];
			if (res.indexOf(a) === -1) {
				res.push(a);
			}
		}
		return res.join("");
	}

	function replaceAll(str, match, newV) {
		if (typeof match === 'object') {
			let res = str;
			for (let i = 0; i < match.length; i++) {
				res = replaceAll(res, match[i], newV);
			}
			return res;
		}
		oldVal = '';
		while (oldVal != str) {
			oldVal = str;
			str = str.replace(match, newV);
		}
		return str;
	}

	function parseSynonyms(fn) {
		for (let i = 0; i < synonyms.length; i += 2) {
			fn = replaceAll(fn, synonyms[i], synonyms[i + 1]);
		}
		return fn;
	}
</script>

<style>
	#results {
		margin: 12px;
		background: #fafafa;
		padding: 20px;
		padding-bottom: 8px;
		margin-top: 30px;
		border-radius: 8px;
		box-shadow: 0px 0px 20px 8px rgba(0, 0, 0, 0.27);
	}

	#results div {
		padding-bottom: 12px;
		overflow: auto;
	}

	#evaluerenRes,
	#evalwarn {
		opacity: 0;
		transition-duration: 600ms;
	}

	#evaluerenRes.shown,
	#evalwarn.shown {
		opacity: 1;
	}

	@media only screen and (min-width: 800px) {
		#rescols {
			column-count: 2;
		}

		#rescols div {
			overflow-x: auto;
		}
	}
</style>